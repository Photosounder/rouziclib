:toc:

= rouziclib

This is my library of code that is common to all my different projects such as https://photosounder.com[Photosounder], https://photosounder.com/spiral/[Spiral] and https://photosounder.com/splineeq/[SplineEQ], but also lesser projects such as my minimalistic https://github.com/Photosounder/rouziclib-picture-viewer[picture viewer], my https://github.com/Photosounder/screenshot-tool[screenshot tool] or my modernised version of NASA's https://github.com/Photosounder/Voyager-Image-Decoder[Voyager Image Decoder] as well as projects you don't know about such as my private project Spacewar where all my new code is born.

== What it does

It includes some of the following:

* Fast lookup table-based fixed-point arithmetic approximations for sqrt, hypot, log2, exp2, pow, cos, atan2 (both noting angles in http://en.wikipedia.org/wiki/Turn_(geometry)[turns], not radians), the Gaussian function (http://www.wolframalpha.com/input/?i=e%5E-x%C2%B2[e^-xÂ²^]) and the raised error function (https://www.wolframalpha.com/input/?i=0.5%2B0.5erf(x)[0.5+0.5erf(x)]). Some are implemented using linear interpolation, segmented quadratic polynomial approximation or simple lookup, which offers different levels of speed/precision/memory usage tradeoffs.
* Fast polynomial lookup table-based floating-point approximations for cos, log2, exp2, pow and others.
* Original math functions such as a short Gaussian function and its integral, the short error function which I now use for filter design. I also created an approximation of the inverse of the error function accurate to about 10^-12^.
* Functions to draw lines, points, circles, roundrects and gradients, all antialiased with Gaussian filtering
* Functions to convert from sRGB to linear RGB for loading images and to convert from linear RGB to sRGB with optional Gaussian dithering for displaying
* Geometric functions used for computing intersections between lines, shortest the distance of a point to a line or to limit a line to a bounding box
* Blending modes like additive, subtractive, multiplicative blending and alpha blending
* Blitting of a buffer onto another, like for displaying a sprite
* An original Hue-Saturation-Luminance colour space with a Luminance that is about perceptually correct (unlike the 1931 CIE XYZ colour space which gets the weights of each colour blatantly wrong) which is used for HSL to RGB conversion and for bringing out of gamut colours (such as colours that have components brighter than 1.0) to the most appropriate representable colour
* Vector font generation, vector text rendering and a built-in minimalistic vector font that is always available. A more complete typeface is available in the link:vector_type[vector_type] directory
* Vector procedural zoomable interface elements that for instance allow you to have a fully functional button just by calling a function with all the necessary information provided as parameters (without anything stored in memory) and simply getting the return value, with no need for storage for each instance of a control, no unique IDs or anything
* Functions to conveniently do operations on point vectors (2D or 3D) or rectangles and triangles, such as generating rectangle coordinates based on position, size and offset vectors, or calculating the scaling and positioning needed to make a rectangle fit in a certain way inside another rectangle. This forms the basis of the aforementioned interface system.
* A drawing queue-based graphical system that lets the main thread queue drawing commands and then is rendered on the GPU using OpenCL or the CPU in a threaded way
* A file concatenation feature called fileball similar to tarball that I use to pack and compress many files together as one header that can be included in an executable in a portable compiler-independent way, like my vector typeface.
* Convenient directory-listing and file management features
* Built-in dependency-free loading of various image formats (https://github.com/nothings/stb/blob/master/stb_image.h[JPG, PNG, BMP, PSD], TIFF, https://heasarc.gsfc.nasa.gov/docs/heasarc/fits.html[NASA]'s FITS), saving of images (32-bit TIFF, https://github.com/nothings/stb/blob/master/stb_image_write.h[PNG, JPG, BMP]), loading of sounds (AIFF, WAVE, https://github.com/lieff/minimp3/blob/master/minimp3.h[MP3], https://github.com/mackron/dr_libs/blob/master/dr_flac.h[FLAC], https://github.com/nothings/stb/blob/master/stb_vorbis.c[OGG]) and saving of sounds (AIFF, WAVE).
* Modified libraries such as a version of https://github.com/zywina/cfftpack[cfftpack] modified so that both single and double precision floating point FFTs can be done in the same program (not possible with the original) or a version of https://github.com/tronkko/dirent[dirent] modified to fix some path length and Unicode conversion bugs, or a cut-down version of https://github.com/nigels-com/glew[GLEW] that contains only what rouziclib needs.
* Fast tiled mipmap generation, image rescaling based on https://photosounder.com/michel_rouzic/#flattop[flat-top bilinear filtering], Gaussian blurring, an original texture compression and YUV coding/decoding in C and OpenCL.
* A system for loading and saving an application's preferences to one file but in a non-centralised way with just a simple value query being enough to add a new value in its proper place
* A sound system so that multiple functions can play sounds at the same time by providing a callback
* Functions to easily resize buffers as needed and a generic buffer system based on this with many functions that replicate how outputing to a file stream works
* Binary searching of arrays
* Functions to convert between UTF-8, UTF-16 and Unicode codepoints. A subset of these functions forms the basis for https://github.com/Photosounder/fopen_utf8[fopen_utf8] which I recommend you use if you need to fopen UTF-8 paths on Windows.
* Various functions to parse or format strings
* Various utility functions and macros
* Code for working with https://www.libsdl.org/[SDL], OpenGL, https://www.khronos.org/opencl/[OpenCL], https://github.com/clMathLibraries/clFFT[clFFT], http://openil.sourceforge.net/[DevIL], http://opencv.org/[OpenCV], https://www.ffmpeg.org/[FFMPEG], https://www.libraw.org/[LibRAW] and http://www.mpfr.org/[MPFR].

All graphical functions operate on pixels in a linear colour space. Please do not use these functions directly in a gamma-compressed colour space, instead use an intermediary linear framebuffer which you can then convert to an sRGB framebuffer using the function `convert_lrgb_to_srgb`.

== How to use it

Unusually for a library, rouziclib's code relies on macros that are defined inside your project's code. This means that rouziclib isn't entirely independently compiled. So the way to make this work is to create two files in your project, a header file which directly includes the main header, but not before you add the macros you can optionally define, and a code file which includes the aforementioned header file you just created and then includes the library's rouziclib.c. Here's how it looks:

rl.h

[source,C]
----
#ifndef H_PRL
#define H_PRL
#ifdef __cplusplus
extern "C" {
#endif

// these are examples of optional macros that rouziclib will then use for your project
#define COL_FRGB    // this macro makes the internal format for colour be floating-point instead of fixed-point
#define RL_SDL      // this includes SDL-using code as well as the necessary SDL files
#define RL_OPENCL   // same for OpenCL

// this defines a wrapper for fprintf_rl, so your project can use a custom fprintf-type function that can for instance output to a file
#define fprintf_rl fprintf_wrapper
#include <stdio.h>
#include <stdarg.h>
extern void fprintf_wrapper (FILE *stream, const char* format, ...);

#include <rouziclib/rouziclib.h>

#ifdef __cplusplus
}
#endif
#endif
----

rl.c

[source,C]
----
#include "rl.h"

// this creates that custom printing function that all calls to fprintf_rl in rouziclib will use

void fprintf_wrapper (FILE *stream, const char* format, ...)
{
    va_list args;

    va_start (args, format);

    vfprintf (stream, format, args);    // printf to original stream
    fflush (stream);

    va_end (args);
}

#include <rouziclib/rouziclib.c>
----

I realise that this is a bit unusual, but it's pretty simple and very handy. You can for instance include rouziclib in a simple command-line C program without having to worry about dependencies as none will be included, and in another project add dependencies as you need by adding the necessary macros, so without having the recompile anything separately (as you would have to were you to use two versions of a same library compiled with different dependencies) you can have in separate projects a rouziclib with no dependencies or a rouziclib that uses SDL, DevIL, OpenCV, OpenCL, clFFT, FFMPEG and LibRAW.

== Example project
Have a look at a minimal https://github.com/Photosounder/rouziclib-picture-viewer[picture viewer] built around rouziclib, with explanations of its features, how it works and how to expand on it or create a similar program.

== Files

* link:rouziclib/rouziclib.c[rouziclib.c] / link:rouziclib/rouziclib.h[rouziclib.h] / link:rouziclib/rouziclib.m[rouziclib.m] +
Every piece of code in this library is ultimately included into one of those three files, so it's as if this whole library was only made of 2 (or 3 on macOS) files. Basically rouziclib is just like a two-file library broken down into over 360 files due to size.

* link:rouziclib/general[general/]

** link:rouziclib/general/xyz.c[xyz.c] / link:rouziclib/general/xyz.h[xyz.h] and link:rouziclib/general/xyz_struct.h[xyz_struct.h] +
Vectors (2D, 3D integer 2D and 3x3 matrices) with conversions and operations. Very widely used throughout the library.

** link:rouziclib/general/time.c[time.c] / link:rouziclib/general/time.h[time.h] +
Multiplatform standard and high resolution time-measuring, sleep, date-time string parsing and Julian date conversion.

** link:rouziclib/general/estimates.c[estimates.c] / link:rouziclib/general/estimates.h[estimates.h] +
Functions for estimating the program's framerate.

** link:rouziclib/general/mouse.c[mouse.c] / link:rouziclib/general/mouse.h[mouse.h] and link:rouziclib/general/mouse_struct.h[mouse_struct.h] +
Mouse cursor logic and cursor drawing.

** link:rouziclib/general/keyboard.c[keyboard.c] / link:rouziclib/general/keyboard.h[keyboard.h] and link:rouziclib/general/keyboard_struct.h[keyboard_struct.h] +
Processing SDL keyboard events to update arrays of flags while avoiding missing quick presses like when both the down and up event arrive at the same time. Also controls the zoom-scroll system from key combos.

** link:rouziclib/general/noop.c[noop.c] / link:rouziclib/general/noop.h[noop.h] +
Functions that do nothing and say so when that's needed.

** link:rouziclib/general/hashing.c[hashing.c] / link:rouziclib/general/hashing.h[hashing.h] +
Functions for hashing using https://github.com/Cyan4973/xxHash/[xxHash].

** link:rouziclib/general/threading.c[threading.c] / link:rouziclib/general/threading.h[threading.h] +
Multiplatform threading, mainly wrappers for https://github.com/mattiasgustavsson/libs/blob/main/thread.h[thread.h].

** link:rouziclib/general/intrinsics.c[intrinsics.c] / link:rouziclib/general/intrinsics.h[intrinsics.h] +
Functions for testing Intel x86 CPU features at runtime, replacements for certain intrinsics that can be missing or inefficient, macros that simplify basic operations.

** link:rouziclib/general/crash_dump.c[crash_dump.c] / link:rouziclib/general/crash_dump.h[crash_dump.h] +
Windows-only functions to generate a minidump file in case the program crashes.

** link:rouziclib/general/audio.c[audio.c] / link:rouziclib/general/audio.h[audio.h] +
Audio system that can call multiple callbacks, mix their outputs, register them, deregister and stop running them automatically.

** link:rouziclib/general/structs.h[structs.h] +
Generic buffer structure and generic lookup table structure.

** link:rouziclib/general/globals.c[globals.c] / link:rouziclib/general/globals.h[globals.h] +
Creates the globals used by the various system in rouziclib, such as the framebuffer structure (thread-local so that other threads can render to a framebuffer and therefore use the usual drawing and GUI functions, like when rendering a video), the zoom-scroll state, the mouse-keyboard state, the vector typeface, the audio system, the window manager as well as the default drawing thickness.

* link:rouziclib/memory[memory/]

** link:rouziclib/memory/alloc.c[alloc.c] / link:rouziclib/memory/alloc.h[alloc.h] +
Manages allocations, reallocations, deallocations, copying, 2D arrays and managing an allocation list. Contains the very essential `alloc_enough()` which I use extensively to resize buffers as needed.

** link:rouziclib/memory/fill.c[fill.c] / link:rouziclib/memory/fill.h[fill.h] +
Like `memset()` but with 32 and 64-bit words instead of 8 bits.

** link:rouziclib/memory/swap.c[swap.c] / link:rouziclib/memory/swap.h[swap.h] +
Functions to swap two values.

** link:rouziclib/memory/circular_buffer.c[circular_buffer.c] / link:rouziclib/memory/circular_buffer.h[circular_buffer.h] +
Manages circular buffers by wrapping indices around and doing the equivalent of `memset()` and `memcpy()` on circular buffers or from linear buffers to circular buffers.

** link:rouziclib/memory/generic_buffer.c[generic_buffer.c] / link:rouziclib/memory/generic_buffer.h[generic_buffer.h] +
A generic buffer is a structure that contains a buffer (usually used as a string, otherwise as a byte stream) as well as a count of how many bytes are currently used and how many are allocated. This allows for the buffer to be enlarged as needed, to avoid inefficiencies that come from running `strlen()` to know where a string ends, and to have functions that behave on strings just like on a `FILE` pointer. For instance `bufprintf()` works just like `fprintf()` except on a string (as a generic buffer), which is rather convenient, and `bufwrite()` works like `fwrite()`, which makes creating binary files in memory much easier.

** link:rouziclib/memory/comparison.c[comparison.c] / link:rouziclib/memory/comparison.h[comparison.h] +
Contains often-needed comparison functions that like `strcmp()` can be used with `qsort()` or `bsearch()`. `array_find_index_by_cmp()` uses binary searching to find an index in a pre-sorted array based on a given value.

* link:rouziclib/geometry[geometry/]

** link:rouziclib/geometry/rect.c[rect.c] / link:rouziclib/geometry/rect.h[rect.h] and link:rouziclib/geometry/rect_struct.h[rect_struct.h] +
Vectors for rectangles, integer rectangles and triangles, and functions to create, transform or get information from such rectangles.

** link:rouziclib/geometry/intersection.c[intersection.c] / link:rouziclib/geometry/intersection.h[intersection.h] +
Functions to computer intersections between lines, find the distance between a point and a line, find the segment of a line inside a rectangle, intersect rectangles, intersect a circle with a rectangle, find if a point is inside a rectangle or circle, or find the angular radius of a circle from a point.

** link:rouziclib/geometry/rotation.c[rotation.c] / link:rouziclib/geometry/rotation.h[rotation.h] +
Handle 2D and 3D vector rotation.

** link:rouziclib/geometry/fit.c[fit.c] / link:rouziclib/geometry/fit.h[fit.h] +
Functions to find how to best fit squares or rectangles in an area, manage a Hilbert curve grid, fit a rectangle inside a rectangular area or subdivide a rectangle.

** link:rouziclib/geometry/distance.c[distance.c] / link:rouziclib/geometry/distance.h[distance.h] +
Calculate the hypothenuse in 2D and 3D and move a point away from another point using a given distance multiplier.

** link:rouziclib/geometry/bezier.c[bezier.c] / link:rouziclib/geometry/bezier.h[bezier.h] +
Can turn an array of points into an array of cubic BÃ©zier segments with automatic handles and evaluate an entire array of BÃ©zier segments for a given value of `x`.

** link:rouziclib/geometry/misc.c[misc.c] / link:rouziclib/geometry/misc.h[misc.h] +
Mainly triangle functions.

* link:rouziclib/math[math/]

** link:rouziclib/math/functions.c[functions.c] / link:rouziclib/math/functions.h[functions.h] +
Basic math functions, an approximation of the inverse error function, functions to find a value or interpolated value from an array of 2D points.

** link:rouziclib/math/ieee754.c[ieee754.c] / link:rouziclib/math/ieee754.h[ieee754.h] +
IEEE-754 floating point manipulation, fractional part calculation and dealing with numbers at the level of https://en.wikipedia.org/wiki/Unit_in_the_last_place[units of least precision] to guarantee incrementation or make floating point comparisons that take a degree of error into account.

** link:rouziclib/math/rand.c[rand.c] / link:rouziclib/math/rand.h[rand.h] +
Functions to generate uniform pseudo-random numbers in a given range, nmumbers with a normal (Gaussian) distribution and a PRNG based on MINSTD.

** link:rouziclib/math/dsp.c[dsp.c] / link:rouziclib/math/dsp.h[dsp.h] +
FFT size calculation, basic array operations, root mean square computation, decibel conversion, Blackman window, short Gaussian window (an original way to make a Gaussian window finite with desirable characteristics) and its integral, polynomial step functions, ramp filter kernel computation.

** link:rouziclib/math/dct.c[dct.c] / link:rouziclib/math/dct.h[dct.h] +
Discrete Cosine Transform computation for JPEG 8x8 blocks.

** link:rouziclib/math/matrix.c[matrix.c] / link:rouziclib/math/matrix.h[matrix.h] +
Matrix determinant and inverse, including MPFR versions.

** link:rouziclib/math/physics.c[physics.c] / link:rouziclib/math/physics.h[physics.h] +
Euler physical integration.

** link:rouziclib/math/debug.c[debug.c] / link:rouziclib/math/debug.h[debug.h] +
Something used by my graphing calculator.

** link:rouziclib/math/polynomials.c[polynomials.c] / link:rouziclib/math/polynomials.h[polynomials.h] +
Polynomial evaluation (1D and 2D), error calculation for approximations, coefficient operations, Chebyshev fitting by discrete cosine transform, conversion of Chebyshev coefficients to polynomial coefficients, digit reduction to make coefficients take up less digits and an attempt at optimising fits to reduce the maximum error.

** link:rouziclib/math/erf_radlim.c[erf_radlim.c] / link:rouziclib/math/erf_radlim.h[erf_radlim.h] +
Part of my attempts at directly computing Gaussian-antialiased triangles.

* link:rouziclib/fixedpoint[fixedpoint/] and link:rouziclib/fastfloat[fastfloat/]

** link:rouziclib/fixedpoint/fp.c[fp.c] / link:rouziclib/fixedpoint/fp.h[fp.h] +
Fixed point approximations for the square root, division, log2m exp2, cosine, atan2, the Gaussian function and the error function.

** link:rouziclib/fastfloat/fastfloat.c[fastfloat.c] / link:rouziclib/fastfloat/fastfloat.h[fastfloat.h] +
Floating point approximations for log2, exp2, pow, the square root (which tends to be slower than just using `sqrt()`), linear to sRGB gamma conversion and exp over a small range.

** link:rouziclib/fastfloat/fastcos.c[fastcos.c] / link:rouziclib/fastfloat/fastcos.h[fastcos.h] +
Floating point approximations for the cosine at different levels of precision, in turns or radians.

** link:rouziclib/fastfloat/simd.c[simd.c] / link:rouziclib/fastfloat/simd.h[simd.h] +
Intel x86 SIMD versions of Gaussian, error function and linear to sRGB conversion approximations.

* link:rouziclib/graphics[graphics/]

** link:rouziclib/graphics/graphics.c[graphics.c] / link:rouziclib/graphics/graphics.h[graphics.h] and link:rouziclib/graphics/graphics_struct.h[graphics_struct.h] +
Functions to manage the `raster_t` and `framebuffer_t` structures and access pixels in various formats.

** link:rouziclib/graphics/pixel_conv.c[pixel_conv.c] / link:rouziclib/graphics/pixel_conv.h[pixel_conv.h] +
Conversions between different pixel formats, with Intel x86 SIMD versions.

** link:rouziclib/graphics/srgb.c[srgb.c] / link:rouziclib/graphics/srgb.h[srgb.h] +
Conversions between linear valued and gamma-compressed sRGB.

** link:rouziclib/graphics/sqrgb.c[sqrgb.c] / link:rouziclib/graphics/sqrgb.h[sqrgb.h] +
Conversions for the 10-bit square root pixel format.

** link:rouziclib/graphics/yuv.c[yuv.c] / link:rouziclib/graphics/yuv.h[yuv.h] +
YUV conversions.

** link:rouziclib/graphics/colour.c[colour.c] / link:rouziclib/graphics/colour.h[colour.h] +
Colour operations, inversion, HSL conversions, channel access, out-of-gamut desaturation and luminosity adjustment.

** link:rouziclib/graphics/blending.c[blending.c] / link:rouziclib/graphics/blending.h[blending.h] and link:rouziclib/graphics/blending_struct.h[blending_struct.h] +
Pixel blending functions.

** link:rouziclib/graphics/blit.c[blit.c] / link:rouziclib/graphics/blit.h[blit.h] +
Image blitting with no scaling, flat-top filtering or bilinear interpolation and rotation.

** link:rouziclib/graphics/drawline.c[drawline.c] / link:rouziclib/graphics/drawline.h[drawline.h] +
Draw Gaussian-antialiased thin lines and Gaussian dots. Also contains a generic Bresenham line drawing function that takes a function pointer to edit a pixel in custom ways.

** link:rouziclib/graphics/drawrect.c[drawrect.c] / link:rouziclib/graphics/drawrect.h[drawrect.h] +
Draw Gaussian-antialiased full or dark rectangles.

** link:rouziclib/graphics/drawprimitives.c[drawprimitives.c] / link:rouziclib/graphics/drawprimitives.h[drawprimitives.h] +
Draw Gaussian-antialiased circles (full or hollow), hollow rectangles and chamfered (angular) rectangles, rounded rectangles, dashed lines, Gaussian gradients and dots, triangles and mouse cursors.

** link:rouziclib/graphics/drawqueue.c[drawqueue.c] / link:rouziclib/graphics/drawqueue.h[drawqueue.h] +
Drawing queue rendering system.

** link:rouziclib/graphics/drawqueue[drawqueue/]

*** link:rouziclib/graphics/drawqueue/drawqueue_soft.c[drawqueue_soft.c] / link:rouziclib/graphics/drawqueue/drawqueue_soft.h[drawqueue_soft.h] +
Render drawing queue on the CPU with multiple threads using SIMD instructions. Used as a fallback for the OpenCL renderer. The 3 files that follow implement the functions needed by this system to draw rectangles, lines and images.

*** link:rouziclib/graphics/drawqueue/drawrect.c[drawrect.c] / link:rouziclib/graphics/drawqueue/drawrect.h[drawrect.h] +
*** link:rouziclib/graphics/drawqueue/drawline.c[drawline.c] / link:rouziclib/graphics/drawqueue/drawline.h[drawline.h] +
*** link:rouziclib/graphics/drawqueue/blit.c[blit.c] / link:rouziclib/graphics/drawqueue/blit.h[blit.h] +

*** link:rouziclib/graphics/drawqueue/opencl[opencl/] +
The files below make up the OpenCL version of my drawing queue renderer.

**** link:rouziclib/graphics/drawqueue/opencl/bits.cl[bits.cl] +
Read bits in a binary stream. Used for decoding my compressed texture format which uses 3 bits per pixel.

**** link:rouziclib/graphics/drawqueue/opencl/blending.cl[blending.cl] +
Various blending modes available when closing a bracket.

**** link:rouziclib/graphics/drawqueue/opencl/blit.cl[blit.cl] +
Read textures in various formats and blit them with flat-top filtering or bilinear interpolation and rotation.

**** link:rouziclib/graphics/drawqueue/opencl/colour.cl[colour.cl] +
CIELab L, YUV and HSL conversions, colour matrix and transfer curves.

**** link:rouziclib/graphics/drawqueue/opencl/drawcircle.cl[drawcircle.cl] +
Draw full and hollow Gaussian-antialiased circles.

**** link:rouziclib/graphics/drawqueue/opencl/drawline.cl[drawline.cl] +
Draw Gaussian-antialiased thin lines and Gaussian dots.

**** link:rouziclib/graphics/drawqueue/opencl/drawqueue.cl[drawqueue.cl] +
Includes all the other .cl files and is compiled to link:rouziclib/graphics/drawqueue/opencl/drawqueue.cl.h[drawqueue.cl.h] for inclusion in the program, which then gets compiled by the OpenCL compiler at run time to generate the OpenCL kernels. Reads the buffers sent from the host and interprets them to execute the drawing functions.

**** link:rouziclib/graphics/drawqueue/opencl/drawrect.cl[drawrect.cl] +
Draw full Gaussian-antialiased rectangles, either additively or with multiplication to make dark rectangles. Can also add a plain colour to a rendering sector which is used in optimising the drawing of the insides of full rectangles and circles far from the edges.

**** link:rouziclib/graphics/drawqueue/opencl/gaussian.cl[gaussian.cl] +
Fast error function (`erf()`) approximation.

**** link:rouziclib/graphics/drawqueue/opencl/rand.cl[rand.cl] +
MINSTD-based PRNG used to generate a practically non-repeating Gaussian noise texture used for dithering.

**** link:rouziclib/graphics/drawqueue/opencl/srgb.cl[srgb.cl] +
sRGB conversions, out-of-gamut colour desaturation and Gaussian dithering and optional quantisation (with `max_s`) to simulate lower colour bit depths.

**** link:rouziclib/graphics/drawqueue/opencl/trig.cl[trig.cl] +
Arccos and arcsin approximations.

** link:rouziclib/graphics/draw_effects.c[draw_effects.c] / link:rouziclib/graphics/draw_effects.h[draw_effects.h] +
Apply effects to the image using the drawqueue system.

** link:rouziclib/graphics/processing.c[processing.c] / link:rouziclib/graphics/processing.h[processing.h] +
Apply Gaussian blur to an image, scale an image using flat-top filtering, interpolate a pixel with bilinear interpolation and apply operations to pixels.

** link:rouziclib/graphics/mipmap.c[mipmap.c] / link:rouziclib/graphics/mipmap.h[mipmap.h] +
Turns a simple raster image into a multi-level tiled mipmap.

** link:rouziclib/graphics/cl_memory.c[cl_memory.c] / link:rouziclib/graphics/cl_memory.h[cl_memory.h] +
Manage the memory buffer used to exchange data by the drawqueue system. For instance an image that must be displayed on screen will have its pixel data copied to the big buffer, then when using OpenCL the updated parts of that buffer will be copied to the GPU so that a GPU-side mirror of this buffer is maintained and the image can be displayed using the OpenCL code on the GPU.

** link:rouziclib/graphics/texture_compression.c[texture_compression.c] / link:rouziclib/graphics/texture_compression.h[texture_compression.h] +
My original texture compression. It compresses each block of pixels to 3-bits and uses two colours for each block, giving 8 possible colours being interpolated between those two colours.

* link:rouziclib/vector[vector/]

** link:rouziclib/vector/vector.c[vector.c] / link:rouziclib/vector/vector.h[vector.h] and link:rouziclib/vector/vector_struct.h[vector_struct.h] +
How vector objects (represented as a collection of thin lines) are represented and manipulated.

** link:rouziclib/vector/polyline.c[polyline.c] / link:rouziclib/vector/polyline.h[polyline.h] +
A crude tool to create vector objects by mouse.

* link:rouziclib/text[text/]

** link:rouziclib/text/unicode_data.c[unicode_data.c] / link:rouziclib/text/unicode_data.h[unicode_data.h] +
Gives access to Unicode data about each Unicode codepoint.

** link:rouziclib/text/unicode.c[unicode.c] / link:rouziclib/text/unicode.h[unicode.h] +
Functions to deal with UTF-8 or UTF-16 strings.

** link:rouziclib/text/unicode_bidi.c[unicode_bidi.c] / link:rouziclib/text/unicode_bidi.h[unicode_bidi.h] +
Used to decompose a UTF-8 string into sections depending on the directionality of its codepoints (for instance when mixing Arabic, Latin and digits).

** link:rouziclib/text/unicode_arabic.c[unicode_arabic.c] / link:rouziclib/text/unicode_arabic.h[unicode_arabic.h] +
Allows the text renderer to know which form of an Arabic letter to use.

** link:rouziclib/text/parse.c[parse.c] / link:rouziclib/text/parse.h[parse.h] +
Various text parsing tools to skip parts of a string, extract fields according to separators, convert my dozenal number format (for instance "1;4" becomes 1.333...), count lines, find lines, convert a multiline string into an array of lines, case insensitive string search, `memmem()` replacement where needed, pattern finding (like date-time or timestamps), parse files with XY vector data, parse XML fields, parse musical notes such as "G#3+02.1".

** link:rouziclib/text/format.c[format.c] / link:rouziclib/text/format.h[format.h] +
Various string printing functions to print large numbers in a readable way, print dozenal numbers, print English ordinals (like 1st, 4th, 11th, 22nd), convert short months like "Jan" to long months like "January", transform date strings, print compilation and compiler information, indent lines, print time, print duration in a nice readable way (like "1 day and 8.3 hours"), print timestamps, convert text to a C string literal with proper escaping and conversion of a file to a C header that contains a string representing the contents of the file.

** link:rouziclib/text/string.c[string.c] / link:rouziclib/text/string.h[string.h] +
String utilities to copy strings, replace all instances of a character in a string, convert a string to lowercase, alternatives to `sprintf()` with options to allocate, reallocate and append, string line insertion or replacement.

** link:rouziclib/text/edit.c[edit.c] / link:rouziclib/text/edit.h[edit.h] and link:rouziclib/general/textedit_struct.h[textedit_struct.h] +
Text editor GUI control with undo functionality.

** link:rouziclib/text/undo.c[undo.c] / link:rouziclib/text/undo.h[undo.h] +
Undo functionality of text editor controls.

** link:rouziclib/text/history.c[history.c] / link:rouziclib/text/history.h[history.h] +
I have no idea what this is, wtf.

* link:rouziclib/vector_type[vector_type/]

** link:rouziclib/vector_type/vector_type.c[vector_type.c] / link:rouziclib/vector_type/vector_type.h[vector_type.h] and link:rouziclib/vector_type/vector_type_struct.h[vector_type_struct.h] +
Mainly contains functions to retrieve glyphs from codepoints.

** link:rouziclib/vector_type/make_font.c[make_font.c] / link:rouziclib/vector_type/make_font.h[make_font.h] +
Generates the vector typeface from the markup.

** link:rouziclib/vector_type/draw.c[draw.c] / link:rouziclib/vector_type/draw.h[draw.h] +
Draw a string on screen using the vector typeface.

** link:rouziclib/vector_type/stats.c[stats.c] / link:rouziclib/vector_type/stats.h[stats.h] +
Functions to obtain the width of glyphs, and using those find the width of words and lines, which are then used to fit strings into rectangles.

** link:rouziclib/vector_type/fit.c[fit.c] / link:rouziclib/vector_type/fit.h[fit.h] +
Fit strings into rectangles with line breaks either to maximise the size of the letters or to break the lines at a given threshold. Currently only works with strings that don't already contain line breaks, except for `draw_string_bestfit_asis()` which doesn't add line breaks.

** link:rouziclib/vector_type/cjk.c[cjk.c] / link:rouziclib/vector_type/cjk.h[cjk.h] +
Generates CJK glyphs by combining strokes using a list of combinations. Doesn't really produce anything readable.

** link:rouziclib/vector_type/insert_rect.c[insert_rect.c] / link:rouziclib/vector_type/insert_rect.h[insert_rect.h] +
An insert rect is a space in a string to be drawn on screen, and that space has its coordinates reported so that they can be used to insert an interface element where the space is. The width of the space is specified by combining private use Unicode codepoints that each represent a different spacing, the sum of which is the width of the space, and then a variation selector character which represents an index in an array. So for example by using the character that represents a space of 36 units, followed by the character that represents 3 units, followed by the character that represents an index of 0, I can make a space 39 units wide in some text and then by querying the insert rect at index 0 get the on-screen coordinates for that space so that I can place something there. I use it mainly for inserting text edit controls to enter a value in the middle of some text, so the text input field is automatically adjusted to be the right size and position to fit in perfectly.

* link:rouziclib/gui[gui/]

** link:rouziclib/gui/zoom.c[zoom.c] / link:rouziclib/gui/zoom.h[zoom.h] and link:rouziclib/gui/zoom_struct.h[zoom_struct.h] +
Zoom-scroll system, with conversion between "world coordinates" (positions on the infinite plane) and screen coordinates and handling of the mouse to scroll around, zoom in and out, reset the view or change the zoom level and focus programatically. The GUI system relies on this system.

** link:rouziclib/gui/focus.c[focus.c] / link:rouziclib/gui/focus.h[focus.h] and link:rouziclib/gui/focus_struct.h[focus_struct.h] +
Can affect the drawing thickness and brightness of drawn elements to simulate a camera being out of focus, albeit with Gaussian blur rather than a circular kernel.

** link:rouziclib/gui/positioning.c[positioning.c] / link:rouziclib/gui/positioning.h[positioning.h] +
Convert local coordinates to world coordinates using an offset and scale. This is used when making interface elements fit into an area.

** link:rouziclib/gui/layout.c[layout.c] / link:rouziclib/gui/layout.h[layout.h] +
Manage control grids.

** link:rouziclib/gui/drawelements.c[drawelements.c] / link:rouziclib/gui/drawelements.h[drawelements.h] +
Drawing functions for various interface elements.

** link:rouziclib/gui/visualisations.c[visualisations.c] / link:rouziclib/gui/visualisations.h[visualisations.h] +
Draw a bar graph.

** link:rouziclib/gui/inputprocessing.c[inputprocessing.c] / link:rouziclib/gui/inputprocessing.h[inputprocessing.h] and link:rouziclib/gui/inputprocessing_struct.h[inputprocessing_struct.h] +
The core of the GUI system, this is how controls are identified when hovered or clicked and how each type of control processes mouse inputs.

** link:rouziclib/gui/knob_functions.c[knob_functions.c] / link:rouziclib/gui/knob_functions.h[knob_functions.h] +
Knobs can use a few different functions so that they don't have to always be linear.

** link:rouziclib/gui/controls.c[controls.c] / link:rouziclib/gui/controls.h[controls.h] and link:rouziclib/gui/controls_struct.h[controls_struct.h] +
How the basic GUI controls are created.

** link:rouziclib/gui/control_array.c[control_array.c] / link:rouziclib/gui/control_array.h[control_array.h] +
Program arrays of controls.

** link:rouziclib/gui/selection.c[selection.c] / link:rouziclib/gui/selection.h[selection.h] +
Generic selection logic, the kind you expect when selecting files in a folder.

** link:rouziclib/gui/make_gui.c[make_gui.c] / link:rouziclib/gui/make_gui.h[make_gui.h] +
Make a GUI from layout markup, which can be generated by using the toolbar found in the next file. Contains functions to implement every element type using the data in a layout structure and various functions to modify them.

** link:rouziclib/gui/editor_toolbar.c[editor_toolbar.c] / link:rouziclib/gui/editor_toolbar.h[editor_toolbar.h] +
Toolbar to create and modify GUI layouts.

** link:rouziclib/gui/floating_window.c[floating_window.c] / link:rouziclib/gui/floating_window.h[floating_window.h] +
Create and handle floating windows with a draggable title bar, a resizing control, a pinning control and a closing button.

* link:rouziclib/fileio[fileio/]

** link:rouziclib/fileio/bits.c[bits.c] / link:rouziclib/fileio/bits.h[bits.h] +
Read, set or manipulate bits in a bit stream.

** link:rouziclib/fileio/open.c[open.c] / link:rouziclib/fileio/open.h[open.h] +
`fopen()` wrapper that takes UTF-8 paths, with another version that can create any folder needed to make the file being opened writable, query a file's size, load a file into memory, optionally with conversion of DOS line endings, save a whole buffer or string or array of strings to file, count lines in a text file, check if a file or folder exists.

** link:rouziclib/fileio/endian.c[endian.c] / link:rouziclib/fileio/endian.h[endian.h] +
Functions to load or write 8 to 64 bit integers in little or big endian to and from memory, file or generic buffer. By default to speed things up the platform is assumed to be little endian, this can be changed by defining `RL_DONT_ASSUME_LITTLE_ENDIAN`.

** link:rouziclib/fileio/image.c[image.c] / link:rouziclib/fileio/image.h[image.h] +
Convert images between different pixel formats, load and save images and image tiles in various formats, partly using https://github.com/nothings/stb/blob/master/stb_image.h[stb_image] and https://github.com/nothings/stb/blob/master/stb_image_write.h[stb_image_write].

** link:rouziclib/fileio/image_bmp.c[image_bmp.c] / link:rouziclib/fileio/image_bmp.h[image_bmp.h] +
Save BMP images.

** link:rouziclib/fileio/image_tiff.c[image_tiff.c] / link:rouziclib/fileio/image_tiff.h[image_tiff.h] +
Load TIFF files in 8, 16 and 32-bit bits per channel, with either no compression or LZW compression. Save images to 32-bit per channel TIFF files.

** link:rouziclib/fileio/image_tiff_lzw.c[image_tiff_lzw.c] / link:rouziclib/fileio/image_tiff_lzw.h[image_tiff_lzw.h] +
TIFF LZW decoder.

** link:rouziclib/fileio/image_fts.c[image_fts.c] / link:rouziclib/fileio/image_fts.h[image_fts.h] +
Load NASA FITS images. Only tested with SOHO mission images.

** link:rouziclib/fileio/image_screen.c[image_screen.c] / link:rouziclib/fileio/image_screen.h[image_screen.h] +
Function to take screenshots of the main display on Windows.

** link:rouziclib/fileio/sound_format.c[sound_format.c] / link:rouziclib/fileio/sound_format.h[sound_format.h] +
Convert between different sound sample formats and channel layouts.

** link:rouziclib/fileio/sound_aiff.c[sound_aiff.c] / link:rouziclib/fileio/sound_aiff.h[sound_aiff.h] +
Load and save AIFF sound files.

** link:rouziclib/fileio/sound_wav.c[sound_wav.c] / link:rouziclib/fileio/sound_wav.h[sound_wav.h] +
Load and save WAVE sound files.

** link:rouziclib/fileio/path.c[path.c] / link:rouziclib/fileio/path.h[path.h] +
Transform file paths to remove, extract or append elements, make appdata paths to save configuration files, check that a path is to an image or video file or change the current working directory.

** link:rouziclib/fileio/dir.c[dir.c] / link:rouziclib/fileio/dir.h[dir.h] and link:rouziclib/fileio/dir_struct.h[dir_struct.h] +
Load a directory to any depth as a tree using a modified version of link:rouziclib/libraries/dirent.c[dirent.c] / link:rouziclib/libraries/dirent.h[dirent.h] (I fixed some bugs from the original this was based on and reorganised it a bit) on Windows. Query volumes and their free space on Windows.

** link:rouziclib/fileio/file_management.c[file_management.c] / link:rouziclib/fileio/file_management.h[file_management.h] +
Create symbolic links, folders (even with multiple depths), move, copy, remove files and folders, open files or URLs in whatever program they're usually opened, show files in Explorer (Windows).

** link:rouziclib/fileio/process.c[process.c] / link:rouziclib/fileio/process.h[process.h] +
Launch another process (Windows). Load the program's commandline arguments `argv` at any point in the program.

** link:rouziclib/fileio/fileball.c[fileball.c] / link:rouziclib/fileio/fileball.h[fileball.h] and link:rouziclib/fileio/fileball_struct.h[fileball_struct.h] +
Manage fileball archives, a simple format to pack many files into one and optionally compress them using Deflate (via https://github.com/richgel999/miniz[miniz]). This is used to pack the many files that make up the vector typeface into a C header with compression.

** link:rouziclib/fileio/prefs.c[prefs.c] / link:rouziclib/fileio/prefs.h[prefs.h] +
Preference management system. This is what I use to load and save preferences in my programs. Besides being quite elegant and readable it can be used independently by different parts of a program without any awareness of what the other parts do.

** link:rouziclib/fileio/dialog.c[dialog.c] / link:rouziclib/fileio/dialog.h[dialog.h] +
Open and Save file dialogs on Windows and macOS. Both platforms use the same filter format.

** link:rouziclib/fileio/ffmpeg_sound_player.c[ffmpeg_sound_player.c] / link:rouziclib/fileio/ffmpeg_sound_player.h[ffmpeg_sound_player.h] +
Callback to load and play an audio stream using FFMPEG. The seeking leaves a bit to be desired, it can be quite slow compared to the video stream seeking and I don't know why.

* link:rouziclib/network[network/] +
TCP and HTTP socket-based code. Not very useful anymore since everything requires HTTPS.

** link:rouziclib/network/network.c[network.c] / link:rouziclib/network/network.h[network.h] +
** link:rouziclib/network/http.c[http.c] / link:rouziclib/network/http.h[http.h] +

* link:rouziclib/libraries[libraries/]

** link:rouziclib/libraries/opencl.c[opencl.c] / link:rouziclib/libraries/opencl.h[opencl.h] and link:rouziclib/libraries/opencl_struct.h[opencl_struct.h] +
OpenCL code for initialising a context, compiling a kernel and more. Relies on https://github.com/martijnberger/clew[CLEW].

** link:rouziclib/libraries/sdl.c[sdl.c] / link:rouziclib/libraries/sdl.h[sdl.h] +
SDL2 code to get display and driver information, handle various types of events, control the mouse cursor, initialise graphics and audio, use the clipboard, poll drag-and-drop file events.

** link:rouziclib/libraries/vulkan.c[vulkan.c] / link:rouziclib/libraries/vulkan.h[vulkan.h] and link:rouziclib/libraries/vulkan_struct.h[vulkan_struct.h] +
Aborted attempt to port my OpenCL system to Vulkan. Vulkan is rather complicated.

** link:rouziclib/libraries/clfft.c[clfft.c] / link:rouziclib/libraries/clfft.h[clfft.h] +
Code for dealing with https://github.com/clMathLibraries/clFFT[clFFT].

** link:rouziclib/libraries/ffmpeg.c[ffmpeg.c] / link:rouziclib/libraries/ffmpeg.h[ffmpeg.h] +
FFMPEG-based decoding.

** link:rouziclib/libraries/ffmpeg_enc.c[ffmpeg_enc.c] / link:rouziclib/libraries/ffmpeg_enc.h[ffmpeg_enc.h] +
FFMPEG-based encoding (video-only, no audio).

** link:rouziclib/libraries/opencv.c[opencv.c] / link:rouziclib/libraries/opencv.h[opencv.h] +
Decode videos and access webcam images using OpenCV.

** link:rouziclib/libraries/devil.c[devil.c] / link:rouziclib/libraries/devil.h[devil.h] +
Load images with DevIL. I don't use this anymore.

** link:rouziclib/libraries/libsndfile.c[libsndfile.c] / link:rouziclib/libraries/libsndfile.h[libsndfile.h] +
Open files for libsndfile. I also don't use this anymore.

** link:rouziclib/libraries/libraw.c[libraw.c] / link:rouziclib/libraries/libraw.h[libraw.h] +
Load RAW photographs with LibRAW in different ways.

** link:rouziclib/libraries/libjpeg.c[libjpeg.c] / link:rouziclib/libraries/libjpeg.h[libjpeg.h] +
Load JPEG with libJPEG and access DCT blocks.

** link:rouziclib/libraries/libstb_image.c[libstb_image.c] / link:rouziclib/libraries/libstb_image.h[libstb_image.h] +
Load and save images with https://github.com/nothings/stb/blob/master/stb_image.h[stb_image].

** link:rouziclib/libraries/libstb_vorbis.c[libstb_vorbis.c] / link:rouziclib/libraries/libstb_vorbis.h[libstb_vorbis.h] +
Load OGG sound files with https://github.com/nothings/stb/blob/master/stb_vorbis.c[stb_vorbis].

** link:rouziclib/libraries/libminimp3.c[libminimp3.c] / link:rouziclib/libraries/libminimp3.h[libminimp3.h] +
Load MP3s with https://github.com/lieff/minimp3/blob/master/minimp3.h[minimp3].

** link:rouziclib/libraries/libdr_flac.c[libdr_flac.c] / link:rouziclib/libraries/libdr_flac.h[libdr_flac.h] +
Load FLAC sound files with https://github.com/mackron/dr_libs/blob/master/dr_flac.h[dr_flac].

** link:rouziclib/libraries/zlib.c[zlib.c] / link:rouziclib/libraries/zlib.h[zlib.h] +
Compress or decompress using the Deflate compression using either zlib or https://github.com/richgel999/miniz[miniz] (miniz is built in rouziclib so there's no reason to use zlib).

** link:rouziclib/libraries/mpfr.c[mpfr.c] / link:rouziclib/libraries/mpfr.h[mpfr.h] +
Macros to make MPFR syntax simpler (I used to have problems typing `mpfr_` correctly so I changed it to `r_`) and some other functions I need.

** link:rouziclib/libraries/fftpack.c[fftpack.c] / link:rouziclib/libraries/fftpack.h[fftpack.h] +
Older FFTPACK code, only handles real-to-real transforms with no negative frequencies.

** link:rouziclib/libraries/cfftpack.c[cfftpack.c] / link:rouziclib/libraries/cfftpack.h[cfftpack.h] +
https://github.com/zywina/cfftpack[FFTPACK] code with both single and double precision available at the same time (I modified the code it's based on for this purpose). Does 1D and 2D complex-binned FFTs with negative frequencies, padding, conversion betwen real and complex bins, mixing single and double precision, padding, reallocation, and recompution or reallocation plans only as needed.

** link:rouziclib/libraries/tinyexpr.c[tinyexpr.c] / link:rouziclib/libraries/tinyexpr.h[tinyexpr.h] +
https://github.com/codeplea/tinyexpr[TinyExpr] (logic branch) code which I use for many purposes, like parsing markup, knob text input evaluation, making graphing and image calculators. I added several of the functions I need and made `etof()` and `etoi()` as equivalents to `atof()` and `atoi()` but with mathematical expressions rather than simple number strings.

** link:rouziclib/libraries/libcurl.c[libcurl.c] / link:rouziclib/libraries/libcurl.h[libcurl.h] +
cURL code to get files through HTTPS. I can't seem to get authentication right.

** link:rouziclib/libraries/libminiaudio.c[libminiaudio.c] / link:rouziclib/libraries/libminiaudio.h[libminiaudio.h] +
Adds https://github.com/mackron/miniaudio[MiniAudio]. Excluded by default due to the code size

** link:rouziclib/libraries/openal.c[openal.c] / link:rouziclib/libraries/openal.h[openal.h] +
Adds OpenAL.

** link:rouziclib/libraries/emscripten.c[emscripten.c] / link:rouziclib/libraries/emscripten.h[emscripten.h] / link:rouziclib/libraries/emscripten.js[emscripten.js] +
Emscripten-specific code.

** link:rouziclib/libraries/orig[orig/] +
This where I put libraries I use from third parties. Several of them have modifications which are described in the link:rouziclib/libraries/orig/update_notes.txt[update notes].

== Vector typeface

The link:vector_type/[vector_type] folder contains the files that make up my vector typeface which is embedded into rouziclib. Unlike usual digital typefaces which typically define outlines using splines, with a set of different fixed weights, my typeface defines strokes, it is only made of thin straight lines and it has only one weight which is infinity thinness. Simplicity is the goal, both simplicity of design, each glyph is made of a few straight lines, no curves, no outlines, no weights, so the glyph for A is defined with 3 straight lines instead of a more typical 10 or 11 for outlines, and simplicity of implementation, as every glyph can be displayed provided only that the current display system (I currently have 4 different display systems in rouziclib (fixed-point framebuffer, floating-point framebuffer, OpenCL drawing queue and CPU multithreaded SIMD drawing queue) and every system lacks features that another system might have) has an implementation for `draw_line_thin()`.

Another difference with typical computer fonts is that the files that make up my typeface are meant to be read and edited by hand (although my project Spacewar contains tools to generate glyphs, which I used mainly to make Japanese kana glyphs by tracing). I believe that readable text markup is a powerful way to represent anything, be it entire projects (like the PHA files of Photosounder), configuration files, or as in this case the data and commands needed to generate a typeface. Unlike meme formats like XML or JSON it's more readable, elegant, natural and doesn't require the use of a parsing library (little more than `sscanf()` is needed to parse my markup), it doesn't require specialised tools, because it's more understandable the data is more portable, and because it's so simple and natural it's more future-proof, a future parser can easily make use of outdated markup.

=== Structure

When rouziclib loads the typeface, it starts by loading link:vector_type/type_index.txt[type_index.txt], which itself points to 3 types of files through 3 commands.

* `range` points to a file that represents a Unicode range of glyphs. The range start and end points indicated are only there so that my glyph design tool (in Spacewar) would know in which file to put a glyph.

* `substitutions` points to the file that defines certain glyphs as being exactly another glyph. For instance the Greek &#927;, the Cyrillic &#1054; and the Armenian &#1365; all look pretty similar to the Latin O, so substitution is used. When the renderer tries to render a Cyrillic &#1054; it draws the Latin O instead, so we don't even store a copy of the substituted glyph.

* `cjkdecomp` contains commands (coded as a number) to assemble two CJK glyphs into a new one, so that the basic strokes I designed can be assembled into making any CJK glyph. Because it's a rather heavy file and that very few glyphs looked correct it's excluded from the compressed header used to embed the typeface in a program. It's based on https://github.com/amake/cjk-decomp/blob/master/cjk-decomp.txt[this file] and hopefully one day in the future I'll have a better more solid way of generating CJK glyphs.

=== Glyph notation

Let's have a look at a simple glyph, A:

```
glyph 'A'
        p1      2       0
        p2      1;2;8   2;4
        p3      0       6
        mirror  v 0     p1 p2   p4
        lines   p1 p3 p4
        lines   p2 p5
        bounds  -1;9 1;9
```

There are many things to explain. The shape of the glyph A is defined by only 3 points, this is because it's a symmetrical glyph, it would be inelegant to not automate symmetry along the vertical axis. So 3 points are defined, `p1`, the bottom of the right leg at x=2 and y=0 (x=0 is the middle of the glyph, y=0 is the baseline, y=6 is the cap height), `p3` is the top middle point, and `p2` defines the middle bar. Points `p1` to `p2` are then mirrored along the vertical axis, the mirrored points starting from `p4`, and then those 5 points need to be connected to form lines, `p1` to `p3` and then `p4` to form the &#923; part of the glyph, and then `p2` to `p5` for the horizontal line. The last command is optional but quite necessary for such a glyph, it's used for https://en.wikipedia.org/wiki/Kerning[kerning]. Without it the glyph would be considered to have bounds at x=-2 and x=2, which in the case of such glyphs such as A or T looks wrong, it makes them look like they're too far away from other letters. So by setting narrower bounds the distance to other letters (which is 1.5 units by default) is reduced, in this case by 0.25 units.

=== Quasi-base 12 notation

Now you must be wondering, what's going on with the semicolons? What can "1;2;8" possibly mean? Well you see, it's nice to define points on a 4 by 6 grid, but what if you need to go finer, what if you need to put a point on a third of a unit? Should I write it as "0.33333333333333"? That's very inelegant. We use base 10, and the problem with this is that it's only good if you want to represent halves, fifths or tenths. If you want to represent thirds, sixths, ninths or twelfths it's absolutely horrible. Unfortunately using thirds is a very essential part of geometrically designing such things as glyphs, so I wanted a better approach. I chose to represent numbers as a combination of fractions of powers of 12, separated by a semicolon. For instance 2;10;8 means 2 + 10/12 + 8/144, in other words 2.888888888888. Since it's not a strict dozenal representation it's easy to type (no need for special characters for 10 and 11), and since it's a way to represent fractions real numbers can be used to make up for the deficiencies of a dozenal system. For instance 1/60 (0.01666666) in strict dozenal notation also yields an endless number, whereas which my approach I can simply write it as 0;0.2, which means 0 + 0.2/12. It's simple and elegant.

The point `p2` of the glyph A is a good example of the need for such notation. The middle bar looked way too high at a height of 3 units, even 2.5 units looked too high, and 2 and a third seemed like a natural choice, so it was convenient to represent the height as 2;4. Then came the problem of the horizontal position, the bar has to stop right where it means the diagonal lines. That means it has to stop at a x position of 2 * (6-(2+1/3))/6 = 1.2222222222, or 1;2;8. The number 1;2;8, by only taking 5 characters yet having full precision, fits nicely in its 8-character column. When designing things geometrically you need to think in terms of fractions and formulas, therefore a suitable representation is needed. That itself helps you in not being scared of using fractions that are inconvenient to use in decimal notation.

I also use a similar notation for angles. For geometrical design I think it's most sensible to think of angles as fractions of a full circle, using radians would be absurd, and in a way traditional notation by degrees lets you do this, but in a flawed way (because you must multiply everything by 360 and 360 isn't a multiple of 16, and frankly I'm not a fan of using a strange number like 45 to represent an eighth of a circle). If you want to represent an angle that is a third of a circle, it would make sense to represent it as 0;4. However since in geometry there is hardly any use for angles that are larger than a full circle, that means every angle in my notation would have to start with "0;". So I do away with it and simply represent a third of a circle as 4. This notation has advantages over using degrees, for instance 1/32 of a circle is 11.25&#176;, a number that I wouldn't be like to find without using a calculator, but simply 0;4;6 in my representation, a number that I can find by simple successive halvings starting from a quarter of a circle: 3 &#8594; 1;6 &#8594; 0;9 &#8594; 0;4;6 (and it's easy to go on a bit longer, &#8594; 0;2;3 &#8594; 0;1;1;6, only by 1/256 of a circle does it get harder). That representation also has the benefit of matching the familiar clock face, you already know what a 2 o'clock angle looks like.

=== Curved segments, subglyphs and other advanced features

I use this notation in designing glyphs for rotations or the command called `curveseg` which defines a new point that forms a line that forms a curve by defining an angle to the previous line in the curve, and also defining a length that is either a ratio of the previous line's length or an absolute length. My design for the glyph &#1421; is a good example of this:

```
glyph 058D
	subglyph A
	p1      0       0
	p2      0       0;10;9
	curveseg p3     0;9     0;10x
	curveseg p4     0;9     0;10;3x
	curveseg p5     0;9     0;10;6x
	curveseg p6     0;9     0;10;9x
	curveseg p7     0;9     0;11x
	curveseg p8     0;9     0;11;3x
	curveseg p9     0;9     0;11;6x
	curveseg p10    0;9     0;11;9x
	curveseg p11    0;9     0;10;0;10;5x
	lines p1 to p11
	subend

	copy 058D A
	rotate 1;6
	copy 058D A
	rotate 1;6
	copy 058D A
	rotate 1;6
	copy 058D A
	rotate 1;6
	copy 058D A
	rotate 1;6
	copy 058D A
	rotate 1;6
	copy 058D A
	rotate 1;6
	copy 058D A
	rotate 1;6
	move 0 3
```

It starts with a subglyph called "A" (subglyphs get a single ASCII character to identify them), a subglyph which will be copied, then the whole glyph rotated by 1;6 (one eigths of a circle or 45&#176;), this process repeated eight times and then the whole glyph moved up 3 units to be properly centered. The design of the subglyph, which is one branch of the symbol, is the most interesting. It starts with a vertical line, `p1`, the center of the whole glyph and start of this branch, and `p2`, the first point along the curve. The vertical position of `p2` defines the scale of the glyph, if `p2` was only 0;9 instead of 0;10;9 the whole glyph would be exactly the same except about 84% its current size. The point `p3` is defined using `curveseg`, and what the first parameter means is that the line p2-p3 forms an angle of 0;9 (1/16 of a circle or 22.5&#176;) with the previous line (p1-p2). The second parameter means that the line p2-p3 is 0;10 times the length of the previous line. The lines that follow are each smaller than the line that immediately precedes by a given ratio, however this ratio progressively increases. This means that which lines become smaller and smaller, their length changes less and less. As the ratio goes towards 1, the curve becomes more circular, so that while our branch starts off a bit like a logarithmic spiral, in the end it becomes almost circular. It would be impossible to design such a glyph, least of all in such an elegant manner, without a command like `curveseg`. Note that the last line, p10 to p11, had its length ratio finely adjusted so that it would stop where it meets the next branch.

++++
<p align="center">
  <img src="./tools/img/058D.png">
</p>
<p align="center">
  The glyph &#1421; as it appears in Spacewar's typeface editor.
</p>
++++

More such commands are briefly described in link:rouziclib/vector_type/make_font.h[make_font.h], such as `rect` to create points that form a rectangle, `circle` to create any number of points along a circle, and commands to move, scale, rotate or shear a glyph or parts of a glyph to help in combining glyphs or subglyphs.

== Tools

Tools used to generate parts of rouziclib, such as the compressed typeface header, the many lookup tables or the C header containing the OpenCL code, are described link:tools/[here].

== Quick reference

This library being my own personal library, the documentation is sparse and limited to the bare minimum that I need to use it. The bulk of it is in link:quick_reference.h[quick_reference.h], which has the `.h` suffix only to benefit from syntax highlighting. I consult this file when coding something, as a sort of template. For instance if I want to draw a line, I don't remember the syntax so I just copy the line in `quick_reference.h` that says `draw_line_thin(sc_xy(p0), sc_xy(p1), drawing_thickness, white, blend_add, intensity);` and then adapt it to my needs. Same thing when I want to redimension an array as needed, I search for `alloc_enough` in the file and adapt the relevant line. It can also serve as a checklist of sort, for instance when making threads, to make sure I haven't forgotten anything. Having templates all in one file beats looking through source code for examples of how to use a function, so having a file filled with ready to copy examples of how to use a functionality and occasionally with an explanation of what arguments do is something I recommend. I typically add code to this file when I catch myself looking more than once for an example of code of one functionality of rouziclib.
